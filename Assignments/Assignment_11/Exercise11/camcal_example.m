%% Calibration of the first camera
im1=imread('im1.jpg');
% the given image coordinates were originally localized manually using
% ginput
%[x1,y1]=ginput(8)

x1 = 1.0e+03 * ...
   [0.7435;...
    3.3315;...
    0.8275;...
    3.2835;...
    0.5475;...
    3.9875;...
    0.6715;...
    3.8835];
y1=1.0e+03 * ...
   [0.4455;...
    0.4335;...
    1.7215;...
    1.5615;...
    0.3895;...
    0.3895;...
    2.1415;...
    1.8735];

% image coordinates of points as rows of matrix 'abcdefgh'
abcdefgh=[x1(:) y1(:)];

% world coordinates of the points
ABCDEFGH=[758  0 -295;...
          0  0 -295;...
          758  360 -295;...
          0  360 -295;...
          758  0 0;...
          0  0 0;...
          758  360 0;...
          0  360 0];
      
figure;imshow(im1);hold on
plot(x1,y1,'c+','MarkerSize',10);
labels={'a','b','c','d','e','f','g','h'};
for i=1:length(x1)
    ti=text(x1(i),y1(i),labels{i});
    ti.Color='cyan';
    ti.FontSize=20;
end

%% The task is to implement the missing function 'camcalibDLT.m'.
% The algorithm is summarised on slide 22 of Lecture 8.
% The function takes the homogeneous coordinates of the points as input.
P1=camcalibDLT([ABCDEFGH ones(8,1)], [abcdefgh ones(8,1)]);

%% Check the results by projecting the world points with the estimated P
% % the projected points should overlap with manually localized points
pproj1=P1*[ABCDEFGH';ones(1,8)];
for i=1:8
    plot(pproj1(1,i)/pproj1(3,i),pproj1(2,i)/pproj1(3,i),'cx','MarkerSize',10);
    
end

%% Calibration of the second camera
im2=imread('im2.jpg');

x2=1.0e+03*...
    [0.5835;...
    3.2515;...
    0.6515;...
    3.1995;...
    0.1275;...
    3.7475;...
    0.2475;...
    3.6635];
y2=1.0e+03*...
    [0.4135;...
    0.4015;...
    1.6655;...
    1.5975;...
    0.3215;...
    0.3135;...
    2.0295;...
    1.9335];

figure;imshow(im2);hold on
plot(x2,y2,'c+','MarkerSize',10);
labels={'a','b','c','d','e','f','g','h'};
for i=1:length(x2)
    ti=text(x2(i),y2(i),labels{i});
    ti.Color='cyan';
    ti.FontSize=20;
end
%% Uncomment the following lines after you have implemented 'camcalibDLT.m'
P2=camcalibDLT([ABCDEFGH ones(8,1)], [x2 y2 ones(8,1)]);
      
pproj2=P2*[ABCDEFGH';ones(1,8)];
for i=1:8
    plot(pproj2(1,i)/pproj2(3,i),pproj2(2,i)/pproj2(3,i),'cx','MarkerSize',10);
end

% intrinsic and extrinsic camera parameters K,R,t can be extracted from P
% the following functions are from http://www.robots.ox.ac.uk/~vgg/hzbook/code/
[K1, R1, t1] = vgg_KR_from_P(P1);
[K2, R2, t2] = vgg_KR_from_P(P2);